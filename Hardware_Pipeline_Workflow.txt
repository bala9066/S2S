Hardware Pipeline
Simple Phase Guide for Universal Hardware Design


Version: 2.0 - Universal Hardware Design
Date: January 2026
Scope: RF/Wireless, Digital Controllers, Motor Control, Power Electronics, Industrial Control, and more
â€ƒ
Table of Contents

Right-click and select 'Update Field' to generate the table of contents
â€ƒ
What YOU Do vs What AI Does
This workflow guides you through an 8-phase hardware design process where AI handles calculations, documentation, and code generation while you focus on requirements definition, PCB layout, and FPGA/MCU programming.

PHASE 1: Requirements & Component Selection
What YOU Do:
1. Start conversation in chat
   Examples for different system types:

RF/Wireless Systems: "Design RF system with Xilinx Artix-7 FPGA, buck-boost converters, 40dBm output power, 5-18GHz frequency range, return loss > 10dB"
Digital Controller: "Design a digital controller module with Xilinx Artix-7 FPGA, power supply, DDR, EEPROM and Ethernet"
High-Performance Computing: "Design for Zynq Ultrascale+ module with PCIe Gen3, dual 10GbE, DDR4 memory"
Industrial Control: "Design PLC-style controller with STM32H7, isolated I/O, CAN bus, RS-485, 24V industrial power"
Motor Control: "Design three-phase motor controller with TMS320F28379D DSP, gate drivers, current sensing, resolver interface"
Power Electronics: "Design DC-DC converter module with digital control, 400V input, 48V output, 3kW power, synchronous rectification"
Sensor Interface: "Design multi-sensor acquisition board with 16-bit ADC, 8 channels, SPI/I2C interfaces, isolated power"

2. Answer AI's clarifying questions
â€¢	AI asks: "What input voltage? What package for FPGA/MCU?"
â€¢	You answer: "48V DC input, CSG324 package preferred"

3. Choose components when AI shows options
â€¢	AI shows: "Option 1: XC7A100T $185, Option 2: XC7A200T $295"
â€¢	You pick: "Option 1"
â€¢	AI shows: "Power Module Option 1: LTM4644 $45, Option 2: TPS53647 $12"
â€¢	You pick: "Option 2"

4. Approve or reject the final selection
â€¢	AI shows complete BOM
â€¢	You say: "Approved" or "Change the processor to higher performance version"

What AI Does:
Universal Hardware Design Process:

1.	Parses your requirements â†’ Extracts processor/FPGA type, interfaces, power specs, performance requirements
2.	Creates system-appropriate block diagram
   For RF/Wireless Systems: FPGA/MCU, Multi-rail power converters, RF amplifiers, Matching networks, RF I/O
   For Digital Controllers: Processor/FPGA, Memory subsystem (DDR, EEPROM, Flash), Communication interfaces
   For Motor Control: DSP/MCU, Gate drivers, Current sensors, Position encoders, Protection circuits
   For Power Electronics: Control IC/DSP, Power stage (MOSFETs/IGBTs), Gate drivers, Current/voltage sensing
   For Sensor Systems: ADC/DAC, Signal conditioning, Analog frontend, Digital processor
3.	Searches components â†’ Queries DigiKey/Mouser APIs
   Common categories: Processors (FPGAs, MCUs, DSPs), Memory, Power, Interfaces, Analog, RF-specific
4.	Shows you 2-3 options for each component with price/availability
5.	Performs system-specific calculations:
â€¢	RF Systems: Link budget, return loss, harmonics, P1dB compression
â€¢	Power Systems: Efficiency, ripple, load regulation, thermal dissipation
â€¢	Digital Systems: Timing analysis, bandwidth calculations, memory throughput
â€¢	Motor Control: PWM frequency, dead-time, current loop bandwidth
â€¢	All Systems: Power consumption, thermal analysis, voltage rail requirements
6.	Designs critical circuits (matching networks, compensation, termination, filters)
7.	Generates BOM Excel file with pricing, stock, suppliers
8.	Validates everything: thermal, voltage compatibility, timing, impedance, stability

Outputs:
â€¢	Block diagram (Draw.io XML + visual)
â€¢	System-specific analysis files (RF_LinkBudget.xlsx, Power_Analysis.xlsx, Timing_Analysis.xlsx, etc.)
â€¢	BOM.xlsx (component count and cost varies by complexity)

Time: 60-90 seconds
â€ƒ
PHASE 2: HRS Document
What YOU Do:
Nothing! Just wait - AI generates everything automatically. You can review the Word document after.

What AI Does:
9.	Adds pin numbers to block diagram (from component datasheets)
10.	Generates HRS.docx (50-100 page Word document, content adapted to system type)
Core sections (all system types):
â€¢	System overview and architecture
â€¢	Block diagram with detailed annotations
â€¢	Component descriptions with full specifications
â€¢	Electrical specifications (voltage rails, current budgets)
â€¢	Power requirements and thermal analysis
â€¢	Interface specifications
â€¢	BOM table
â€¢	Test requirements

System-specific sections added based on design type (RF, motor control, power, etc.)

Outputs:
â€¢	HRS.docx (Hardware Requirements Specification - Word format, 50-100 pages)
â€¢	Block_Diagram_Detailed.io (with pin assignments for all major components)

Time: 30 seconds
â€ƒ
PHASE 3: Design Constraints & Compliance
What YOU Do:
Almost nothing! Answer simple questions:
â€¢	AI might ask: "Is this for military/export?" (for ITAR/export control)
â€¢	AI might ask: "What operating temperature range?" (-40Â°C to +85Â°C industrial, etc.)
â€¢	AI might ask: "What safety certifications needed?" (UL, CE, FCC, medical, automotive)

What AI Does:
11.	Generates design constraints:
â€¢	Power rail specifications (voltage tolerance, current, noise)
â€¢	Clock requirements (frequency, jitter, phase noise)
â€¢	I/O standards (LVDS, LVCMOS, LVTTL, RS-485, CML, etc.)
â€¢	PCB layout rules (impedance, length matching, isolation, thermal management)
12.	Checks RoHS compliance (scans for lead, cadmium, mercury, hexavalent chromium)
13.	Checks REACH compliance (hazardous substances - SVHC list)
14.	Checks industry-specific compliance requirements:

Industry	Standards	Cost Estimate
General Electronics	FCC Part 15, CE EMC	$10,000-$20,000
RF/Wireless	FCC Part 15/90, CE RED, ISED, ITAR	$15,000-$50,000
Medical Devices	IEC 60601, ISO 13485, FDA 510(k)	$50,000-$200,000+
Automotive	AEC-Q100/Q200, ISO 26262, CISPR 25	$30,000-$100,000
Industrial	IEC 61010, ATEX, IECEx, UL 508	$20,000-$60,000
Military/Aerospace	MIL-STD-461, MIL-STD-810, DO-254	$100,000-$500,000+

15.	Design recommendations (shielding, filtering, emissions control)
16.	Validates â†’ BLOCKS if critical compliance issues found

Outputs:
â€¢	Design_Constraints.json (machine-readable constraints)
â€¢	Compliance_Report.pdf (includes applicable regulatory warnings)
â€¢	Updated HRS.docx (adds compliance and regulatory section)

Time: 30 seconds

Validation Gate:
â€¢	âœ“ PASS â†’ Continue to Phase 4
â€¢	âœ— FAIL â†’ Must fix compliance issues (blocked)
â€ƒ
PHASE 4: Netlist Generation â­ KEY PHASE
What YOU Do:
Nothing! Fully automatic - just review the generated netlist after

What AI Does:
17.	Reads block diagram (with pin assignments from Phase 2)
18.	Looks up component datasheets for pin definitions (processor/FPGA pinout, memory ICs, power ICs, interface ICs, analog ICs)
19.	Generates logical netlist:
â€¢	Lists all components with reference designators
â€¢	Lists all connections (nets) between components
â€¢	Assigns pin numbers to each connection
â€¢	Net naming conventions: Power nets (VCC_CORE_1V0, VCC_IO_1V8, GND), Digital interface nets (SPI, I2C, UART, Ethernet, USB, CAN), High-speed differential nets (DDR, PCIe, LVDS), Analog nets (ADC, DAC, references), RF nets (if applicable)
20.	Creates TWO formats:
â€¢	EDIF format (.edif file) â†’ For importing to Xpedition/Altium/KiCad
â€¢	Excel format (.xlsx file) â†’ For humans to review
21.	Validates netlist:
â€¢	No floating pins (all pins connected or explicitly marked NC)
â€¢	All power pins properly connected
â€¢	High-speed differential pairs properly paired
â€¢	Unused inputs properly terminated
â€¢	Decoupling capacitors present on all power rails

Outputs:
â€¢	netlist.edif (for EDA tools - industry standard format)
â€¢	netlist.xlsx (human readable, 3+ sheets):
   â€¢ Sheet 1: Nets (organized by function)
   â€¢ Sheet 2: Components (with reference designators and values)
   â€¢ Sheet 3: Pin Assignments (detailed connection table)

Time: 40 seconds

Why This Is Important:
This netlist is generated from logical block diagram, NOT from PCB design!
â€¢	You get netlist BEFORE doing PCB layout
â€¢	PCB designer can import netlist as starting point
â€¢	Not dependent on manual schematic capture
â€¢	Can start Phase 6 (GLR) immediately
â€¢	Reduces errors from manual entry
â€¢	Standard format compatible with all major EDA tools
â€ƒ
PHASE 5: PCB Design ðŸ”§ MANUAL - YOUR TURN
What YOU Do:
Manual PCB design in your EDA tool (Xpedition/Altium/KiCad/Eagle)

22.	Import netlist.edif into your EDA tool
23.	Create/verify schematic (may be auto-generated from netlist)
24.	Design PCB layout:
Board stackup selection (system-dependent):
â€¢	Simple Digital (2-4 layers): Top signals, GND, Power, Bottom signals
â€¢	Complex Digital/FPGA (6-8 layers): Multiple signal routing and ground planes
â€¢	RF/Microwave (6-10 layers): Solid ground planes, no splits under RF
â€¢	High-Power (4-8 layers): 2oz-4oz copper for power layers

Component placement strategies:
â€¢	Group related components (processor + memory, power IC + passives)
â€¢	Power management near loads
â€¢	Decoupling caps very close to IC power pins
â€¢	Connectors at board edges
â€¢	Test points accessible

Routing requirements (from Design_Constraints.json):
â€¢	Power traces: Calculate width based on current (1A â‰ˆ 10-15mil for 1oz copper)
â€¢	High-speed differential pairs: Maintain specified impedance, length match within tolerance
â€¢	RF traces: 50Î© controlled impedance, minimize bends
â€¢	Analog traces: Star routing, guard rings, separate grounds
â€¢	Clock routing: Equal length to all loads, minimize crosstalk

Special layout requirements:
â€¢	Thermal management: Thermal vias under power ICs (50-100 vias)
â€¢	Grounding: Solid ground planes, via stitching
â€¢	High-voltage isolation: Creepage distance per voltage
â€¢	Decoupling: Multiple capacitor values, close placement
25.	Run design rule checks (DRC, ERC, high-speed rules, manufacturing checks)
26.	Generate manufacturing files:
â€¢	Gerber files (RS-274X format) - all layers
â€¢	Drill files (Excellon format)
â€¢	Assembly files (Pick-and-place CSV, BOM)
â€¢	Documentation (Fabrication drawing, Assembly drawing)
27.	Upload to chat: Type "PCB complete" and upload gerbers.zip, drill files, pick-place.csv

What AI Does:
Waits for your files
AI can answer design questions in real-time:
â€¢	"What trace width for 50Î© on FR4 1.6mm with 1oz copper?"
â€¢	"How many thermal vias for a 5W IC?"
â€¢	"What's the length matching tolerance for DDR4 at 2400 MT/s?"
â€¢	"Should I use series or parallel termination for this clock?"

Outputs (YOU CREATE):
â€¢	Schematic PDF (complete circuit diagram)
â€¢	Gerber files (7-15 files depending on layers)
â€¢	Drill files (2-6 files)
â€¢	Pick-and-place CSV (assembly coordinates)
â€¢	BOM from PCB tool
â€¢	Fabrication drawing
â€¢	Assembly drawing

Time: Varies greatly by complexity:
   â€¢ Simple 2-4 layer board: 4-8 hours
   â€¢ Medium complexity FPGA/processor board: 16-40 hours
   â€¢ Complex RF or high-speed design: 40-80 hours
   â€¢ Power electronics with isolation: 20-40 hours
â€ƒ
PHASE 6: GLR Generation
What YOU Do:
Review and approve default signal conditions

28.	AI shows signal table with confidence levels (VERIFIED or VERIFY)
29.	You verify critical signals:
â€¢	Enable/disable pins (power, peripherals, amplifiers)
â€¢	Reset pins (polarity and default state)
â€¢	Chip select pins (active high/low)
â€¢	Safety-critical signals (e-stop, fault, interlock)
â€¢	Boot configuration pins
30.	Type "approve" when all signals verified, or request changes

What AI Does:
31.	Parses netlist.edif for all external interface signals
32.	Identifies all I/O signals by category (system interfaces, peripheral interfaces, analog I/O, digital I/O, power control, RF I/O)
33.	Looks up datasheets for each component to determine pin function, electrical characteristics, default state, I/O standard
34.	Determines for each signal:
â€¢	Voltage level (1.2V, 1.5V, 1.8V, 2.5V, 3.3V, 5.0V, etc.)
â€¢	Direction (Input, Output, Bidirectional, Open-drain)
â€¢	Default condition (High, Low, Hi-Z)
â€¢	I/O standard (LVCMOS, LVTTL, LVDS, SSTL, etc.)
â€¢	Drive strength (current, slew rate)
35.	Generates GLR (Gate-Level Requirements) document in JSON and Excel formats

Outputs:
â€¢	GLR.json (machine-readable format for tools)
â€¢	GLR.xlsx (human-readable spreadsheet with multiple sheets):
   â€¢ Sheet 1: Digital I/O Table
   â€¢ Sheet 2: High-Speed Differential I/O
   â€¢ Sheet 3: Memory Interface (DDR4 example)
   â€¢ Sheet 4: Analog I/O
   â€¢ Sheet 5: Power/Control
   â€¢ Sheet 6: Validation Notes

Time: 40 seconds + 5-15 minutes review (depending on complexity)

Validation Gate:
â€¢	âœ“ PASS â†’ All checks passed, continue to next phase
â€¢	âš  WARNINGS â†’ Issues found but not blocking, user review needed
â€¢	âœ— FAIL â†’ Critical issues found, must fix
â€ƒ
PHASE 7: FPGA/MCU Implementation ðŸ”§ MANUAL/OPTIONAL
What YOU Do:
Choose based on your system:

Option A: FPGA/CPLD System (requires HDL programming)
When you need FPGA: Complex digital logic, high-speed interfaces, reconfigurable hardware, massive parallel I/O, hardware acceleration

36.	Implement FPGA logic (HDL code in Verilog/VHDL/SystemVerilog)
   Example modules: Digital converters, Filters, Modulation, Motor control, Data acquisition, High-speed interfaces
37.	Create RDT (Register Description Table) in Excel:
   Format: Register Name, Address, Width, Access, Default, Description
38.	Create PSQ (Programming Sequence) in Excel:
   Sections: Initialization sequence, Runtime sequences, Fault recovery, Shutdown
39.	Upload FPGA files: Type "FPGA implementation complete" and upload RDT.xlsx, PSQ.xlsx

Option B: MCU/Processor System (firmware programming)
When MCU is sufficient: Standard peripherals, lower I/O count, sequential processing, cost-sensitive, lower power

Option C: Simple Digital Logic (no programming)
Type: "No programmable logic in this design"

What AI Does:
While you implement: Waits for your files, available to answer technical questions
After you upload RDT/PSQ: Validates register map, checks programming sequence logic, verifies timing

Outputs (YOU CREATE):
â€¢	RDT.xlsx (Register Description Table)
â€¢	PSQ.xlsx (Programming Sequence)
â€¢	Optional: RTL source code, project files, bitstream

Time: Highly variable based on complexity (4-200+ hours, or skip if not applicable)
â€ƒ
PHASE 8: Software Development
What YOU Do:
Review and approve generated code

40.	AI shows code preview (example: device driver)
41.	You can request modifications:
â€¢	"Add error handling for communication failures"
â€¢	"Add temperature monitoring function"
â€¢	"Create function to ramp motor speed gradually"
42.	Request additional features (logging, calibration, diagnostics, unit tests)
43.	Approve final code: Type "Code approved" or "Generate final package"

What AI Does:
Automatic software generation from HRS, RDT, PSQ, and GLR:

44.	Generates SRS.docx (Software Requirements Specification, 30-60 pages)
45.	Generates SDD.docx (Software Design Document, 40-80 pages)
46.	Generates driver code in BOTH C and C++:
â€¢	C implementation: Portable, embedded-friendly, minimal dependencies, MISRA-C compliant (optional)
â€¢	C++ implementation: Object-oriented design, RAII, exception handling, STL usage
47.	Generates Qt-based control application (if applicable):
â€¢	Core library (C++ classes)
â€¢	GUI application with control panel, status monitoring, real-time plotting, configuration editor
48.	Performs automatic code review:
â€¢	Static analysis (buffer overflow, null pointers, memory leaks)
â€¢	Security checks (input validation, vulnerabilities)
â€¢	Coding standards compliance (MISRA-C, Google C++ Style)
â€¢	Performance analysis
â€¢	Thread safety (for multi-threaded code)
49.	Auto-fixes identified issues
50.	Generates comprehensive test suite (unit tests, integration tests, coverage report)

Outputs:
â€¢	Documentation: SRS.docx, SDD.docx
â€¢	C implementation: device_driver.c/h, hal_interface.c/h, app_interface.c/h, utils.c/h, Makefile
â€¢	C++ implementation: DeviceDriver.cpp/hpp, HardwareInterface.cpp/hpp, DeviceController.cpp/hpp, CMakeLists.txt
â€¢	Qt GUI application (if applicable): Library source + GUI application
â€¢	Test suite: test_device_driver.c, test_hal.c, test_integration.c, test_runner.c
â€¢	Quality reports: CODE_REVIEW.json, COVERAGE_REPORT.html, STATIC_ANALYSIS.txt
â€¢	Build system: Makefile, CMakeLists.txt, build scripts, README.md

Time: 60-90 seconds

Validation Gate:
â€¢	âœ“ PASS â†’ Code ready for use, proceed to delivery
â€¢	âš  WARNINGS â†’ Non-critical issues, manual review recommended
â€¢	âœ— FAIL â†’ Critical issues found, AI auto-fixes and retries
â€ƒ
Complete Timeline Summary
Phase	You Do	AI Does	Time
1: Requirements & Components	Answer questions, pick options	Search components, generate BOM	60-90 sec
2: HRS Document	Nothing	Generate 50-100 page specification	30 sec
3: Compliance	Answer 1-3 questions	Check regulations, estimate costs	30 sec
4: Netlist â­	Nothing	Generate EDIF + Excel netlist	40 sec
5: PCB Design ðŸ”§	MANUAL - Design PCB layout	Wait (answer questions)	4-80 hrs
6: GLR	Review and approve I/O defaults	Parse netlist, generate I/O specs	40 sec + review
7: FPGA/MCU ðŸ”§	MANUAL - Implement HDL/firmware	Wait (answer questions)	4-200+ hrs or skip
8: Software	Review and approve code	Generate SRS/SDD/code/tests	60-90 sec

Total Automated Time: ~4-5 minutes (AI processing)
Total Manual Time: 8-280+ hours (PCB design + FPGA/MCU implementation)
Total Project Time: Highly variable based on design complexity and experience
â€ƒ
Final Deliverables
Quantity varies by system complexity - typical range: 70-100+ files

Documents (Word/PDF):
51.	HRS.docx - Hardware Requirements Specification (50-100 pages)
52.	SRS.docx - Software Requirements Specification (30-60 pages)
53.	SDD.docx - Software Design Document (40-80 pages)
54.	Compliance_Report.pdf (regulatory requirements, certifications, costs)

Spreadsheets (Excel):
55.	BOM.xlsx (5 sheets: parts, pricing, suppliers, lifecycle, power) - $100-$10,000+ depending on components
56.	Power_Analysis.xlsx (per-rail consumption, efficiency, thermal)
57.	netlist.xlsx (3 sheets: nets, components, pin assignments)
58.	GLR.xlsx (I/O specifications: voltage, directions, standards, drive)
59.	RDT.xlsx (Register Description Table - if FPGA/MCU used)
60.	PSQ.xlsx (Programming Sequence - initialization, runtime, shutdown)
61.	System-specific analysis files (RF_LinkBudget.xlsx, Timing_Analysis.xlsx, etc.)

Design Files:
62.	block_diagram.json (machine-readable)
63.	block_diagram.vsdx or block_diagram.drawio
64.	netlist.edif (for EDA tool import)
65.	design_constraints.json (layout rules, power specs, I/O standards)

Code Files:
C Implementation:
â€¢	device_driver.c + .h
â€¢	hal_interface.c + .h
â€¢	app_interface.c + .h
â€¢	utils.c + .h
â€¢	test_driver.c
â€¢	Makefile
C++ Implementation:
â€¢	DeviceDriver.cpp + .hpp
â€¢	HardwareInterface.cpp + .hpp
â€¢	DeviceController.cpp + .hpp
â€¢	Utils.cpp + .hpp
â€¢	CMakeLists.txt
Qt Application (if generated):
â€¢	libdevicecontrol/ (Qt library - 6-10 source files)
â€¢	ControlApp/ (GUI application - 8-12 source files)

PCB Files (you create):
â€¢	Gerber files (7-15 files depending on layers)
â€¢	Drill files (2-6 files)
â€¢	Pick-and-place CSV
â€¢	Assembly drawing PDF
â€¢	Fabrication drawing PDF

Reports:
â€¢	CODE_REVIEW.json (Quality score, issues, recommendations)
â€¢	COVERAGE_REPORT.html (Test coverage with line-by-line highlighting)
â€¢	STATIC_ANALYSIS.txt (Linter results, warnings, errors)
â€¢	validation_reports/ (Multiple validation logs from each phase)
â€ƒ
Common Questions
Q1: Do I need to know how to code?
A: No for Phases 1-6! Just chat naturally and make selections. Phase 7 requires HDL/firmware knowledge if using FPGA/MCU. Phase 8 generates all application code automatically.

Q2: What types of systems can I design?
A: Almost any electronic hardware: RF/wireless, motor control, power electronics, data acquisition, industrial control, high-speed digital, medical devices, automotive electronics, and more.

Q3: Can I change components mid-process?
A: Yes! Just say "Change processor to STM32H7" and AI updates BOM, power analysis, pin assignments, and all documents automatically.

Q4: What if I don't have Xpedition for PCB?
A: Use any tool! The EDIF netlist format is supported by Altium, KiCad (free), OrCAD, Eagle, and most professional EDA tools.

Q5: Can I skip the FPGA/MCU phase?
A: Yes, if your design doesn't use programmable logic. Just say "No programmable logic" or "Skip Phase 7".

Q6: How much does this cost to run?
A: Varies by complexity: Simple ($0.50-$1.00), Medium ($1.00-$2.00), Complex RF/high-speed ($2.00-$5.00), Very complex ($5.00-$10.00) from API calls.

Q7: Can I run this multiple times to iterate?
A: Yes! Common to run 3-8 times to converge on optimal design (baseline â†’ optimize cost â†’ optimize performance â†’ refine manufacturability).

Q8: What about thermal management?
A: AI calculates thermal dissipation and provides: power per component, junction temperature estimates, heatsink recommendations, thermal via requirements, airflow requirements.

Q9: Do I need domain expertise?
A: Basic understanding helps, but AI handles complex calculations: RF matching/link budgets, power loop compensation, motor FOC algorithms, digital signal integrity, timing analysis.

Q10: What about certification testing?
A: AI identifies required certifications and estimates costs, but you must hire accredited test lab. Budget: FCC/CE ($10K-$30K), Medical ($50K-$200K+), Automotive ($30K-$150K+), Military ($100K-$500K+). Plan 2-6 months for testing.

â€ƒ
Critical Success Factors
Universal Best Practices (All Systems):
Requirements Definition:
â€¢	Clear, specific requirements upfront
â€¢	Realistic performance expectations
â€¢	Budget constraints communicated
â€¢	Timeline requirements stated
â€¢	Operating environment defined
Component Selection:
â€¢	Choose components with good availability (not obsolete)
â€¢	Consider second-source options
â€¢	Check lead times
â€¢	Avoid single points of failure
â€¢	Plan for component aging and lifecycle
Power Management:
â€¢	Proper power sequencing (prevents damage)
â€¢	Adequate current capability (1.5x nominal minimum)
â€¢	Low noise/ripple on sensitive supplies
â€¢	Overcurrent/overvoltage protection
â€¢	Power-good signals monitored
Grounding:
â€¢	Solid ground planes (minimizes impedance)
â€¢	Single-point ground for mixed analog/digital
â€¢	Proper ground return paths
â€¢	Via stitching for EMI control
â€¢	Chassis ground properly connected
Protection:
â€¢	ESD protection on all external interfaces
â€¢	Reverse polarity protection on power inputs
â€¢	Overcurrent limiting
â€¢	Thermal shutdown circuitry
â€¢	Transient suppression (TVS diodes)
Testing:
â€¢	Test points on critical signals
â€¢	Debug headers (JTAG, UART, SPI)
â€¢	LED indicators for status
â€¢	Accessible programming interface
â€¢	Provision for current measurement

System-Specific Critical Factors:
For RF/Wireless Systems:
â€¢	50Î© impedance throughout (minimize reflections)
â€¢	Solid ground plane under RF section
â€¢	Via stitching creates RF shield
â€¢	Physical isolation from noisy digital
â€¢	Quality RF connectors
â€¢	Thermal management for PA
For High-Speed Digital (>100MHz):
â€¢	Controlled impedance traces
â€¢	Length matching (strict for DDR)
â€¢	Minimize vias in high-speed paths
â€¢	Continuous ground return path
â€¢	Proper termination
â€¢	Signal integrity simulation before fab
For Motor Control:
â€¢	Gate driver close to power devices (<2cm)
â€¢	Symmetric current sense traces
â€¢	Power and signal ground separation
â€¢	Thick copper for high-current (2oz+)
â€¢	Emergency stop circuit hardware
For Power Electronics:
â€¢	Minimize hot loop (input cap â†’ switch â†’ output cap)
â€¢	Kelvin connections for current sense
â€¢	Proper gate drive (voltage, current, speed)
â€¢	Creepage/clearance for high voltage
â€¢	Load testing before deployment
For Precision Analog:
â€¢	Guard rings around sensitive traces
â€¢	Star grounding from voltage reference
â€¢	Low-offset layout
â€¢	Shielding from digital noise
â€¢	Calibration provisions in design

================================================================================

The complete universal hardware design pipeline! The AI handles calculations, documentation, and code generation across RF, digital, motor control, power, analog, and any combination. You focus on requirements definition and the creative PCB layout and FPGA/MCU programming.

Total automated time: ~4-5 minutes
Total manual time: Varies by complexity (4-280+ hours)
Total project time: Depends on your design complexity and experience

The workflow is flexible - adapt it to your specific needs by skipping irrelevant phases or adding custom requirements!
